{
  "Converter Test": {
    "prefix": "convtest",
    "body": [
      "import { TestingModule, Test } from '@nestjs/testing'",
      "",
      "describe('$1', () => {",
      "let converter: $1",
      "",
      "beforeEach(async () => {",
      "  const module: TestingModule = await Test.createTestingModule({",
      "    providers: [$1],",
      "  }).compile()",
      "",
      "  converter = module.get<$1>($1)",
      " })",
      "",
      "describe('#$2', () => {",
      "  let response: $3",
      "",
      "  beforeEach(() => {",
      "    response = converter.$2()",
      "  })",
      "",
      "  it('is $4', () => {",
      "    expect(response).toEqual($5)",
      "  })",
      " })",
      "})"
    ]
  },
  "Service Test": {
    "prefix": "servtest",
    "body": [
      "import { TestingModule, Test } from '@nestjs/testing'",
      "",
      "describe('$1', () => {",
      "let service: $1",
      "",
      "beforeEach(async () => {",
      "  const module: TestingModule = await Test.createTestingModule({",
      "    providers: [$1],",
      "  }).compile()",
      "",
      "  service = module.get<$1>($1)",
      " })",
      "",
      "describe('#$2', () => {",
      "  let response: $3",
      "",
      "  beforeEach(() => {",
      "    response = service.$2()",
      "  })",
      "",
      "  it('is $4', () => {",
      "    expect(response).toEqual($5)",
      "  })",
      " })",
      "})"
    ]
  },
  "Worker Test": {
    "prefix": "worktest",
    "body": [
      "import { TestingModule, Test } from '@nestjs/testing'",
      "import { z } from 'zod'",
      "",
      "describe('$1', () => {",
      "let worker: $1",
      "",
      "beforeEach(async () => {",
      "  const module: TestingModule = await Test.createTestingModule({",
      "    providers: [$1],",
      "  }).compile()",
      "",
      "  worker = module.get<$1>($1)",
      " })",
      "",
      "describe('#jobHandler', () => {",
      "  let error: unknown",
      "",
      "  describe('with invalid args', () => {",
      "    beforeEach(async () => {",
      "      try {",
      "        await worker.jobHandler({})",
      "      } catch (e) {",
      "        error = e",
      "      }",
      "    })",
      "",
      " it('throws', () => {",
      "   expect(error).toEqual(",
      "     new Error(",
      "       new z.ZodError([",
      "       ]).message,",
      "     ),",
      "   )",
      "  })",
      "})",
      "})",
      "})"
    ]
  },
  "Repo Test": {
    "prefix": "repotest",
    "body": [
      "import { TestingModule, Test } from '@nestjs/testing'",
      "import { createMockPrisma } from 'test/utils'",
      "import { PrismaService } from '@/database/prisma.service'",
      "import { Result } from 'ts-results'",
      "",
      "const mockConverter = new Mock$Entity1Converter()",
      "",
      "describe('$1Repository', () => {",
      "let repository: $1Repository",
      "const mockPrisma = createMockPrisma()",
      "",
      "beforeEach(async () => {",
      "  const module: TestingModule = await Test.createTestingModule({",
      "    providers: [",
      "      $1Repository,",
      "    {",
      "      provide: PrismaService,",
      "      useValue: mockPrisma,",
      "    },",
      "    {",
      "      provide: $1EntityConverter,",
      "      useValue: mockConverter,",
      "    },",
      "    ],",
      "  }).compile()",
      "",
      "  repository = module.get<$1Repository>($1Repository)",
      " })",
      "",
      "describe('#$2', () => {",
      "  let response: Result<$3, $4>",
      "",
      "  beforeEach(async () => {",
      "    response = await repository.$2()",
      "  })",
      "",
      "  it('is $5', () => {",
      "    expect(response).toEqual($6)",
      "  })",
      " })",
      "})"
    ]
  },
  "Resolver Test": {
    "prefix": "resotest",
    "body": [
      "import { TestingModule, Test } from '@nestjs/testing'",
      "import { AuthGuard } from '@/auth/auth.guard'",
      "import { AuthService } from '@/auth/auth.service'",
      "import { Result } from 'ts-results'",
      "import { MockProxy } from 'jest-mock-extended'",
      "",
      "describe('$1Resolver', () => {",
      "let resolver: $1Resolver",
      "let authGuard: MockProxy<AuthGuard>",
      "",
      "beforeEach(async () => {",
      "  const module: TestingModule = await Test.createTestingModule({",
      "    providers: [",
      "      $1Resolver,",
      "    {",
      "      provide: AuthGuard,",
      "      useValue: authGuard,",
      "    },",
      "    {",
      "      provide: AuthService,",
      "      useValue: {},",
      "    },",
      "    ],",
      "  }).compile()",
      "",
      "  resolver = module.get<$1Resolver>($1Resolver)",
      "  authGuard.canActivate.mockResolvedValue(true)",
      " })",
      "",
      "describe('#$2', () => {",
      "  let response: Result<$3, $4>",
      "",
      "  beforeEach(async () => {",
      "    response = await resolver.$2()",
      "  })",
      "",
      "  it('is $5', () => {",
      "    expect(response).toEqual($6)",
      "  })",
      " })",
      "})"
    ]
  },
  "Typeorm Test": {
    "prefix": "tstorm",
    "body": [
      "import { ExecutionResult } from 'graphql';",
      "import { Connection } from 'typeorm';",
      "",
      "import executeQuery from '../../testUtils/executeQuery';",
      "import loadFixtures, { ICreatedFixtures } from '../utils/loadFixtures';",
      "",
      "@Describe()",
      "class $1 {",
      "   conn: Connection;",
      "   fixtures: ICreatedFixtures;",
      "   res: ExecutionResult;",
      "",
      "   @BeforeAll()",
      "   async load() {",
      "     Object.assign(this, await loadFixtures([$2]));",
      "",
      "     const query = `",
      "       $3",
      "     `;",
      "     ",
      "     this.res = await executeQuery({",
      "       source: query,",
      "       variableValues: {",
      "         $4",
      "       },",
      "       viewerId: this.fixtures.user1.id,",
      "    });",
      "  }",
      "",
      "  @AfterAll()",
      "  async teardown() {",
      "    await this.conn.close();",
      "  }",
      "",
      "  @Test()",
      "  async $5() {",
      "    expect(this.res).toEqual({",
      "      data: {",
      "      },",
      "    })",
      "  }",
      "}"
    ]
  },
  "Resolver": {
    "prefix": "resolver",
    "body": [
      "import { AuthGuard } from '@/auth/auth.guard'",
      "import { err } from '@/common/results'",
      "import { UseGuards } from '@nestjs/common'",
      "import { ResolveField, Resolver } from '@nestjs/graphql'",
      "import { Result } from 'ts-results'",
      "",
      "@UseGuards(AuthGuard)",
      "@Resolver('$1')",
      "export class $2Resolver {",
      "  constructor(private readonly converter: $2DtoConverter, private readonly service: $2Service) {}",
      "",
      "  @ResolveField()",
      "  public async $3(): Promise<Result<$3, $2ResolverError>> {",
      "    try {",
      "      const result = await this.service.$3()",
      "      return result",
      "       .map((record) => this.converter.to$3DTO(record))",
      "       .mapErr((e) => $2Error.from(e))",
      "     } catch (e) {",
      "       return err($2UnexpectedError.from(e))",
      "     }",
      "  }",
      "}"
    ]
  },
  "Expect Error": {
    "prefix": "experr",
    "body": [
      "it('is an error', () => {",
      "  expect(response.err).toBeTruthy()",
      "  expect(response.val).toStrictEqual(new $1('boom'))",
      "})"
    ]
  }
}
